<!DOCTYPE html>

<html>
	<head>
		<title>Simon Blom</title>
		<link rel="stylesheet" href="main.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter">
	</head>
	<body>
		<div class="main-frame">
			<div class="navigation">
				<a href="index.html">Home</a>
				<a href="about.html">About</a>
				<a href="contact.html">Contact</a>
			</div>
			<div class="textbox">
				In this project I wanted to learn more about real-time ray tracing. I wanted to
				build an acceleration structure and implement the ray tracing on the GPU in order
				to obtain real-time performance for a more complicated mesh. On top of that I also
				wanted to explore the concept of combining rasterization and ray tracing.
			</div>
			<div class="textbox">
				This project was implemented with C++ and DirectX 11. The meshes and textures that
				I use in this project are not my own work. All of the work that I show on this page
				represents my own independent work.
			</div>
			<div class="textbox">
				In the model the tracks are represented as one individual tread segment. This is
				useful in situations where you want to animate the tank. To simplify things a bit I
				decided to instead combine all of the segments into a static mesh representing the
				full track. I did that in Maya with the help of NURBS and MASH:
			</div>
			<div class="image-layout">
				<a href="images/01-01.png" style="grid-area: 1 / 1 / 5 /  4;"><img src="images/01-01.png"></a>
				<a href="images/01-02.png" style="grid-area: 1 / 4 / 3 / 13;"><img src="images/01-02.png"></a>
				<a href="images/01-03.png" style="grid-area: 3 / 4 / 5 / 13;"><img src="images/01-03.png"></a>
			</div>
			<div class="textbox">
				The entire model consists of 62703 triangles in total. Since this is too many
				triangles to perform intersection tests against on each frame my first objective
				was to build an acceleration structure.
			</div>
			<div class="textbox">
				The acceleration structure is built at application startup and based on a bounding
				volume hierarchy together with a surface area heuristic. It is built by repeatedly
				splitting the root bounding volume based on three split strategies for each of the
				three axes. Each split is then evaluated by the surface area heuristic and the best
				split is chosen. All of the bounding volumes are then moved into a buffer that the
				GPU can read from.
			</div>
			<div class="textbox">
				This is an example of the resulting acceleration structure for the tank hull at
				depth 0, 4 and 8:
			</div>
			<div class="image-layout">
				<a href="images/01-04.png" style="grid-area: 1 / 1 / 5 /  5;"><img src="images/01-04.png"></a>
				<a href="images/01-05.png" style="grid-area: 1 / 5 / 5 /  9;"><img src="images/01-05.png"></a>
				<a href="images/01-06.png" style="grid-area: 1 / 9 / 5 / 13;"><img src="images/01-06.png"></a>
			</div>
			<div class="textbox">
				With the acceleration structure in place the next objective was to implement the
				ray tracing. In the classical approach you use primary rays going from the camera
				into the scene in order to obtain information about the closest hit. To increase
				the performance I instead use regular rasterization to create three textures that
				hold essentially the same hit information as you would get from a classical
				intersection test:
			</div>
			<div class="image-layout">
				<a href="images/01-07.png" style="grid-area: 1 / 1 / 5 /  5;"><img src="images/01-07.png"></a>
				<a href="images/01-08.png" style="grid-area: 1 / 5 / 5 /  9;"><img src="images/01-08.png"></a>
				<a href="images/01-09.png" style="grid-area: 1 / 9 / 5 / 13;"><img src="images/01-09.png"></a>
			</div>
			<div class="textbox">
				The first texture contains the mesh index in the red channel and the triangle index
				in the green channel while the second texture contains the barycentric coordinate
				and the third texture contains the depth. With these textures I can also
				reconstruct all of the closest hit information such as the albedo color, ambient
				occlusion, surface normal and various material properties such as glossiness and
				metalness:
			</div>
			<div class="image-layout">
				<a href="images/01-10.png" style="grid-area: 1 /  1 / 4 /  4;"><img src="images/01-10.png"></a>
				<a href="images/01-11.png" style="grid-area: 1 /  4 / 4 /  7;"><img src="images/01-11.png"></a>
				<a href="images/01-12.png" style="grid-area: 1 /  7 / 4 / 10;"><img src="images/01-12.png"></a>
				<a href="images/01-13.png" style="grid-area: 1 / 10 / 4 / 13;"><img src="images/01-13.png"></a>
			</div>
			<div class="textbox">
				After the rasterization I use a compute shader to continue the ray tracing. I use
				the information from the three textures to reconstruct the primary rays together
				with their corresponding hit positions in order to compute secondary rays for
				shadows and reflections. These secondary rays are then traced through the
				acceleration structure which in turn returns information about the next hit.
			</div>
			<div class="textbox">
				These are some output examples from the computation of shadow rays:
			</div>
			<div class="image-layout">
				<a href="images/01-14.png" style="grid-area: 1 /  1 / 7 /  7;"><img src="images/01-14.png"></a>
				<a href="images/01-15.png" style="grid-area: 1 /  7 / 4 / 10;"><img src="images/01-15.png"></a>
				<a href="images/01-16.png" style="grid-area: 4 /  7 / 7 / 10;"><img src="images/01-16.png"></a>
				<a href="images/01-17.png" style="grid-area: 1 / 10 / 7 / 13;"><img src="images/01-17.png"></a>
			</div>
			<div class="textbox">
				These are some output examples from the computation of reflection rays:
			</div>
			<div class="image-layout">
				<a href="images/01-18.png" style="grid-area: 1 /  1 / 7 /  7;"><img src="images/01-18.png"></a>
				<a href="images/01-19.png" style="grid-area: 1 /  7 / 4 / 10;"><img src="images/01-19.png"></a>
				<a href="images/01-20.png" style="grid-area: 4 /  7 / 7 / 10;"><img src="images/01-20.png"></a>
				<a href="images/01-21.png" style="grid-area: 1 / 10 / 7 / 13;"><img src="images/01-21.png"></a>
			</div>
			<div class="textbox">
				I use the information from the next hit to both evaluate the incoming illumination
				at each surface point and also to compute further bounces. The ray bouncing is done
				iteratively in order to support a variable amount of bounces. This ends when either
				no hit was found, after a maximum number of bounces or when the light contribution
				falls below a specific threshold. After that I compute the final color of each pixel.
			</div>
			<div class="textbox">
				These are some output examples of the final result with 4 bounces:
			</div>
			<div class="image-layout">
				<a href="images/01-22.png" style="grid-area: 1 /  1 / 7 /  7;"><img src="images/01-22.png"></a>
				<a href="images/01-23.png" style="grid-area: 1 /  7 / 4 / 10;"><img src="images/01-23.png"></a>
				<a href="images/01-24.png" style="grid-area: 4 /  7 / 7 / 10;"><img src="images/01-24.png"></a>
				<a href="images/01-25.png" style="grid-area: 1 / 10 / 7 / 13;"><img src="images/01-25.png"></a>
			</div>
			<div class="textbox">
				This runs at roughly 30 FPS on an NVIDIA GeForce RTX 2070 with the resolution
				1920x1200 together with x2 SSAA and the maximum number of bounces set to 4.
			</div>
			<div class="video-layout">
				<iframe src="https://www.youtube.com/embed/DFCqJlhYQGo?rel=0" allowfullscreen></iframe>
			</div>
			<div class="textbox">
				You can find the project repository <a href="https://github.com/simonblo/dh2323-
				hybrid-raytracer">here</a> which contains all resources and source code.
			</div>
		</div>
	</body>
</html>